The Standard Template Library in C++ consists of four components:

Algorithms
Containers
Functions
Iterators


Substitution failure is not an error (SFINAE) 
refers to a situation in C++ where an invalid substitution of template parameters is not in itself an error

	
	// std::integral_constant<bool,true> (aka std::true_type )
	// std::integral_constant<bool,false> (aka std::false_type )
	// template <class T> struct is_foo;
	// static constexpr bool value true если T удовлетворяет критериям foo , false противном случае функции
	// operator bool Возвращает value
	// этот признак можно использоват в static_assert или std::enable_if 
	// T Тип константы, v Значение константы.
	// вызов value_type() возвращает тип, например int

	template <class T, bool v>
	struct integral_constant 
	{
		static constexpr bool value = v;
		typedef bool value_type;
		typedef integral_constant<T,v> type;
		constexpr operator value_type(){ 
			return v; }
	};

exmaple:

int main()
{
	std::cout << "integral_constant<int, 5> == "
		<< std::integral_constant<int, 5>::value << std::endl;
	std::cout << "integral_constant<bool, false> == " << std::boolalpha
		<< std::integral_constant<bool, false>::value << std::endl;
	return (0);
}

integral_constant<int, 5> == 5
integral_constant<bool, false> == false

constexpr is initialized at compile time. Const may be initialized at compile time or run time
initialization at runtime would be time-consuming 



Explicit (full) template specialization & Partial template specialization
 
template<typename T> // primary template
struct is_void : std::false_type {};
template<>           // explicit specialization for T = void
struct is_void<void> : std::true_type {};
 
int main()
{
    // for any type T other than void, the class is derived from false_type
    std::cout << is_void<char>::value << '\n'; 
    // but when T is void, the class is derived from true_type
    std::cout << is_void<void>::value << '\n';
}

без primary template explicit specialization не будет работать
Specialization must be declared before the first use that would cause implicit instantiation

Partial template specialization

Если наследоваться от др класса, то типы переменных, определеных через typedef нужно заново определять в доч классе, либо обращ через наемспейс наследника как в примере ниже:
#include <iostream>
#include <vector>

template <class T>
struct iter {
	typedef T			value_typeT;
	value_typeT num;
	iter():num(5){};
};

template <class T>
struct iterNew : iter<T>
{
	void print()
	{
		typename iterNew<T>::value_typeT V1;
		V1 = 1;
		
		std::cout<<V1<<std::endl;
		std::cout<<typeid(V1).name()<<std::endl;
	};

};

int main()
{
	iterNew<int> a;
	a.print();
	
	return 0;
}

если в дочке нет переменной abc, а в родителе есть, то чтобы распечатать обязательно нужно вызывать через this->abc
так как в дочке нет abc.

try - catch для alloc.allocate() можно не делать, так как он сам кидает bad alloc.
после throw полед код не исполнится.

SIGSEGV is abbreviation for “Signal Segmentation Violation” (usually signal 11)). 
-> Using uninitialized pointer 
-> De-referencing a NULL pointer 
-> Trying to access memory that the program doesn’t own (eg. trying to access an array element 
out of array bounds). 
-> Trying to access memory which is already de-allocated (trying to use dangling pointers). 
Please refer this article for examples.


 Bus Error (usually signal 10) occur when a process
 is trying to access memory that the CPU cannot physically address

Основное различие между ошибкой сегментации и ошибкой шины заключается в том, 
что ошибка сегментации указывает на недопустимый доступ к действительной памяти, 
а ошибка шины указывает на доступ к недопустимому адресу.


Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity).
- ассоциативные контейнеры

set
collection of unique keys, sorted by keys
(class template)

map 
collection of key-value pairs, sorted by keys, keys are unique
(class template)

A graph is a type of non-linear data structure 
that is used to store data in the form of nodes and edges

Red-black tree. 

strategy of insertion to red-black tree:
1. insert Z
2. recolor and rotate nodes to fix violation

1. if Z is root - then color it to black
2. if Z has red uncle, recolor it is parent, uncle and grand parent
3. if Z has black uncle (triangle), rotate Z and it parent (change them <->)
4. if Z has black uncle (line),
rotate Z parent and grandparent (change them <->),
brother of Z is now right kid of ex-grandparent


without typedef we cannot use types of the class that is in it's temlplate.
Например, у меня есть структура пара :
	template <class key, class value> 
	struct pair
	{

		key first;
		value second;

		pair():first(0), second(0){};

		template<class U, class V> 
			pair (const pair<U,V>& pr):first(pr.first), second(pr.second){ 	};
		pair (const first_type& a, const second_type& b):first(a), second(b){};

		pair& operator= (const pair& pr){
			if (this != &pr){
				first = pr.first;
				second = pr.second;	}
			return *this;}
	};

и вот я созадю дерево, куда передаю пару (1-аргумент):
template <class Pair, class Compare, class Allocator>
	class tree
	{ ... }

но мне хочется передать ключ в функцию search() дерева (tree), как указать тип этого ключа? Без тайпдеф никак
Если бы класс struct pair	{} имела тайпдефы как ниже:
typedef key		first_type;
typedef value 	second_type;

то в своем дереве я могла бы использовать Pair::first_type как в примере ниже
typedef typename Pair::first_type key;

и в нужную функцию дерева передать тип ключа search(const key& k){}

Правило SFINAE гласит: Если не получается рассчитать окончательные типы/значения шаблонных параметров функции, компилятор не выбрасывает ошибку, 
а ищет другую подходящую перегрузку. Ошибка будет в трёх случаях:

Не нашлось ни одной подходящей перегрузки.
Нашлось несколько таких перегрузок, и компилятор не может решить, какую взять.
Перегрузка нашлась, она оказалась шаблонной, и при инстанцировании шаблона случилась ошибка.