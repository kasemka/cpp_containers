The Standard Template Library in C++ consists of four components:

Algorithms
Containers
Functions
Iterators


Substitution failure is not an error (SFINAE) 
refers to a situation in C++ where an invalid substitution of template parameters is not in itself an error

	
	// std::integral_constant<bool,true> (aka std::true_type )
	// std::integral_constant<bool,false> (aka std::false_type )
	// template <class T> struct is_foo;
	// static constexpr bool value true если T удовлетворяет критериям foo , false противном случае функции
	// operator bool Возвращает value
	// этот признак можно использоват в static_assert или std::enable_if 
	// T Тип константы, v Значение константы.
	// вызов value_type() возвращает тип, например int

	template <class T, bool v>
	struct integral_constant 
	{
		static constexpr bool value = v;
		typedef bool value_type;
		typedef integral_constant<T,v> type;
		constexpr operator value_type(){ 
			return v; }
	};

exmaple:

int main()
{
	std::cout << "integral_constant<int, 5> == "
		<< std::integral_constant<int, 5>::value << std::endl;
	std::cout << "integral_constant<bool, false> == " << std::boolalpha
		<< std::integral_constant<bool, false>::value << std::endl;
	return (0);
}

integral_constant<int, 5> == 5
integral_constant<bool, false> == false

constexpr is initialized at compile time. Const may be initialized at compile time or run time
initialization at runtime would be time-consuming 



Explicit (full) template specialization & Partial template specialization
 
template<typename T> // primary template
struct is_void : std::false_type {};
template<>           // explicit specialization for T = void
struct is_void<void> : std::true_type {};
 
int main()
{
    // for any type T other than void, the class is derived from false_type
    std::cout << is_void<char>::value << '\n'; 
    // but when T is void, the class is derived from true_type
    std::cout << is_void<void>::value << '\n';
}

без primary template explicit specialization не будет работать
Specialization must be declared before the first use that would cause implicit instantiation

Partial template specialization

Если наследоваться от др класса, то типы переменных, определеных через typedef нужно заново определять в доч классе, либо обращ через наемспейс наследника как в примере ниже:
#include <iostream>
#include <vector>

template <class T>
struct iter {
	typedef T			value_typeT;
	value_typeT num;
	iter():num(5){};
};

template <class T>
struct iterNew : iter<T>
{
	void print()
	{
		typename iterNew<T>::value_typeT V1;
		V1 = 1;
		
		std::cout<<V1<<std::endl;
		std::cout<<typeid(V1).name()<<std::endl;
	};

};

int main()
{
	iterNew<int> a;
	a.print();
	
	return 0;
}

если в дочке нет переменной abc, а в родителе есть, то чтобы распечатать обязательно нужно вызывать через this->abc
так как в дочке нет abc.
